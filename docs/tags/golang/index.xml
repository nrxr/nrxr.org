<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on nrxr@journal:~$</title>
    <link>https://nrxr.org/tags/golang/</link>
    <description>Recent content in golang on nrxr@journal:~$</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 03 Oct 2019 21:20:40 -0400</lastBuildDate>
    
	<atom:link href="https://nrxr.org/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Copying Pointers in Go</title>
      <link>https://nrxr.org/post/copying-pointers-in-go/</link>
      <pubDate>Thu, 03 Oct 2019 21:20:40 -0400</pubDate>
      
      <guid>https://nrxr.org/post/copying-pointers-in-go/</guid>
      <description>Over a year ago I was trying to make a copy of a *url.URL and ended up with this quite nasty way to do so. I even applied this to maskpass, a small package that masks the password of an url.URL to make it log-friendly.
But today, looking for a nice clean way to do so in a PR being sent to Go I realized tmp := *src does the work nicely.</description>
    </item>
    
    <item>
      <title>Using multi-stage Dockerfile for small Go docker images</title>
      <link>https://nrxr.org/post/multi-stage-docker-for-go/</link>
      <pubDate>Wed, 02 Oct 2019 18:39:10 -0400</pubDate>
      
      <guid>https://nrxr.org/post/multi-stage-docker-for-go/</guid>
      <description>This post will show you how to write a multi-stage Dockerfile and end up with a very small Docker image with just your application binary.
One of the very interesting things of using a compiled programming language like Go is that you end up with tiny binaries, which then you can distribute as such. If combined with Docker you can end up with very tiny images that are faster and cheaper to distribute.</description>
    </item>
    
  </channel>
</rss>
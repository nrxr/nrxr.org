---
title: Understanding enum implementation performance in Go
date: 2023-04-16T03:00:00.000Z
tags:
  - Go
categories:
  - Go
---

I've been writing enum implementations in Go in a certain way for a lot of time. It looks something like:

```go
type Day uint8

const (
  Monday Day = iota
  Tuesday
  Wednesday
)

var dayValues = []string{"Monday", "Tuesday", "Wednesday"}

func (d Day) String() string {
  return dayValues[d]
}
```

\
And if values were not continuous I would just use a `map[string]Type` like what [I proposed a few days back in a `grafana/k6` issue](https://github.com/grafana/k6/issues/2998#issuecomment-1501251892):\
\


```go
// systemtag.go
package systemtag

type SystemTag uint32

const (
  TagProto SystemTag = 1 << iota
  TagSubproto
  TagStatus
)

var tagToValue = map[SystemTag]string{
  TagProto:    "proto",
  TagSubproto: "subproto",
  TagStatus:   "status",
}

func(st SystemTag) String() string {
  return tagToValue[st]
}
```

The response about performance of that approach from a maintainer made me actually benchmark it.

As a developer, the jump from a slice of strings to a map of strings was not that big, in my head the performance hit would not be really important. Yet, it definitely is and looking in the stdlib, I found there's a different approach that does not provides the speed of a slice but it's pretty close.

The net/http package [implements this for returning the string values of HTTP status codes](https://cs.opensource.google/go/go/+/refs/tags/go1.20.3:src/net/http/status.go;l=81). It's > 10x faster than a map of strings and taking into account how little are enum implementations updated, I think it's worth to understand and know when it's a good idea to use. The solution is using switch:

```go
package systemtag

type SystemTag uint32

const (
  TagProto SystemTag = 1 << iota
  TagSubproto
  TagStatus
)

func(st SystemTag) String() string {
  switch st {
    case TagProto:
      return "proto"
    case TagSubproto:
      return "subproto"
    case TagStatus:
      return "status"
    default:
      return ""
  }
}
```

The results were compared against a complex approach generated by the [enumer tool](https://github.com/dmarkham/enumer), using a combination of a single string with all the values and a unsigned integer slice for indexes to retrieve data from that string.

A snippet of the results:

```
goos: darwin
goarch: arm64
pkg: github.com/nrxr/enumbenchmarks/enumer/executionstatus
BenchmarkExecutionStatus_String_LastItem-8     	697159990	         1.599 ns/op
BenchmarkExecutionStatusString_MiddleItem-8    	75749607	        15.95 ns/op
pkg: github.com/nrxr/enumbenchmarks/idiomatic/executionstatus
BenchmarkExecutionStatus_String_LastItem-8     	1000000000	         1.024 ns/op
BenchmarkExecutionStatusString_LastItem-8      	266512113	         4.503 ns/op
pkg: github.com/nrxr/enumbenchmarks/manual/executionstatus
BenchmarkExecutionStatus_String_FirstItem-8    	1000000000	         0.9450 ns/op
BenchmarkExecutionStatusString_LastItem-8      	93189710	        12.81 ns/op
```

The conclusion is that using the slice of strings is preferable but to do the inverse operation the switch case will yield better results. The switch case is more versatile if you want to keep consistency in approaches with all your code.

Both options are easier to maintain than the enumer approach and are better at performance.

I wrote [a Git repository with all the implementations](https://github.com/nrxr/enumbenchmarks), the [benchmark tests](https://github.com/nrxr/enumbenchmarks/tree/master#benchmarks) and [comparisons](https://github.com/nrxr/enumbenchmarks/tree/master#enumer-vs-manual) between [the implementations'](https://github.com/nrxr/enumbenchmarks/tree/master#enumer-vs-idiomatic) performance, in case you're looking for more.

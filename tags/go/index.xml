<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on nrxr@journal:~$</title><link>https://nrxr.org/tags/go/</link><description>Recent content in go on nrxr@journal:~$</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 08 Oct 2020 17:24:00 +0000</lastBuildDate><atom:link href="https://nrxr.org/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Styles Are Important</title><link>https://nrxr.org/post/styles-are-important/</link><pubDate>Thu, 08 Oct 2020 17:24:00 +0000</pubDate><guid>https://nrxr.org/post/styles-are-important/</guid><description>I&amp;rsquo;ve been reviewing a lot of code from candidates for the company I work at and have been discussing about art with some friends. I started to think a lot how I consider code-style very important and a form of art when done correctly.
Styling goes around organizing, writing correctly, naming correctly, documenting correctly.
Is my belief good style comes with time, comes with experience. You won&amp;rsquo;t know right ahead what works and what not.</description></item><item><title>Copying Pointers in Go</title><link>https://nrxr.org/post/copying-pointers-in-go/</link><pubDate>Thu, 03 Oct 2019 21:20:40 -0400</pubDate><guid>https://nrxr.org/post/copying-pointers-in-go/</guid><description>Over a year ago I was trying to make a copy of a *url.URL and ended up with this quite nasty way to do so. I even applied this to maskpass, a small package that masks the password of an url.URL to make it log-friendly.
But today, looking for a nice clean way to do so in a PR being sent to Go I realized tmp := *src does the work nicely.</description></item><item><title>Using multi-stage Dockerfile for small Go docker images</title><link>https://nrxr.org/post/multi-stage-docker-for-go/</link><pubDate>Wed, 02 Oct 2019 18:39:10 -0400</pubDate><guid>https://nrxr.org/post/multi-stage-docker-for-go/</guid><description>This post will show you how to write a multi-stage Dockerfile and end up with a very small Docker image with just your application binary.
One of the very interesting things of using a compiled programming language like Go is that you end up with tiny binaries, which then you can distribute as such. If combined with Docker you can end up with very tiny images that are faster and cheaper to distribute.</description></item><item><title>Can't download go mod from private repository with correct credentials</title><link>https://nrxr.org/post/can-t-download-go-mod-from-private-repository-with-correct-credentials/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nrxr.org/post/can-t-download-go-mod-from-private-repository-with-correct-credentials/</guid><description>Today I tried to run a go mod tidy in my machine and suddendly failed:
1 2 3 4 5 6 7 8 ‚ùØ go mod tidy go: github.com/xxx/abc@v1.0.0 requires github.com/xxx/xyz@v0.1.6: reading github.com/xxx/xyz/go.mod at revision v0.1.6: git ls-remote -q origin in /Users/nrxr/code/pkg/mod/cache/vcs/efbaf026601e6db5d33d6c9020672ec8dd313d341c34f6b77702d1d831b3c925: exit status 128: fatal: &amp;#39;origin&amp;#39; does not appear to be a git repository fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists.</description></item></channel></rss>
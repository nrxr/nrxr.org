<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Using multi-stage Dockerfile for small Go docker images - nrxr@journal:~$</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="This post will show you how to write a multi-stage Dockerfile and end up with a very small Docker image with just your application binary.
One of the very interesting things of using a compiled programming language like Go is that you end up with tiny binaries, which then you can distribute as such. If combined with Docker you can end up with very tiny images that are faster and cheaper to distribute."><meta property="og:image" content><meta property="og:title" content="Using multi-stage Dockerfile for small Go docker images"><meta property="og:description" content="This post will show you how to write a multi-stage Dockerfile and end up with a very small Docker image with just your application binary.
One of the very interesting things of using a compiled programming language like Go is that you end up with tiny binaries, which then you can distribute as such. If combined with Docker you can end up with very tiny images that are faster and cheaper to distribute."><meta property="og:type" content="article"><meta property="og:url" content="https://nrxr.org/post/multi-stage-docker-for-go/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-10-02T18:39:10-04:00"><meta property="article:modified_time" content="2019-10-24T16:06:00-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using multi-stage Dockerfile for small Go docker images"><meta name=twitter:description content="This post will show you how to write a multi-stage Dockerfile and end up with a very small Docker image with just your application binary.
One of the very interesting things of using a compiled programming language like Go is that you end up with tiny binaries, which then you can distribute as such. If combined with Docker you can end up with very tiny images that are faster and cheaper to distribute."><script src=https://nrxr.org/js/feather.min.js></script>
<link href=https://nrxr.org/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://nrxr.org/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><div class=main><a href=https://nrxr.org/>nrxr@journal:~$</a></div><nav><a href=/>Home</a>
<a href=/post/>Archives</a>
<a href=/tags/>Tags</a>
<a href=/categories/>Categories</a></nav></header><main><article><div class=title><h1 class=title>Using multi-stage Dockerfile for small Go docker images</h1><div class=meta>Posted on Oct 2, 2019</div></div><section class=body><p>This post will show you how to write a multi-stage Dockerfile and end up with a
very small Docker image with just your application binary.</p><p>One of the very interesting things of using a compiled programming language like
Go is that you end up with tiny binaries, which then you can distribute as such.
If combined with Docker you can end up with very tiny images that are faster and
cheaper to distribute.</p><h2 id=tldr>TL;DR</h2><p>A simple Dockerfile with such characteristics would look like this:</p><pre><code>FROM golang:alpine AS builder

ENV CGO_ENABLED=0 \
  GOOS=linux \
  GO111MODULE=on

WORKDIR /opt/app

RUN apk --no-cache update &amp;&amp; \
      apk --no-cache add git ca-certificates &amp;&amp; \
      rm -rf /var/cache/apk/*

COPY go.mod .
COPY go.sum .

RUN go mod download

COPY . ./

RUN go build -a -o app .

FROM alpine

RUN apk --no-cache update &amp;&amp; \
      apk --no-cache add ca-certificates &amp;&amp; \
      rm -rf /var/cache/apk/*

COPY --from=builder /opt/app/app /usr/local/bin/app

CMD [&quot;/usr/local/bin/app&quot;, &quot;--help&quot;]
</code></pre><p>You could copy and paste this into a <code>Dockerfile</code> and end up with a fairly small
image and expect to call commands from <code>/usr/local/bin/app</code>.</p><h2 id=what-is-in-the-dockerfile-and-why>What is in the Dockerfile and why</h2><p>Let&rsquo;s start by what&rsquo;s in the first part of the <code>Dockerfile</code> and why it&rsquo;s
organized the way it is:</p><ul><li><code>GOOS=linux</code> is declared so it&rsquo;s pretty clear and explicit what kind of OS the
binary will end up being. I know it seems unnecessary and it may be it, but
I find explicit better than implicit.</li><li><code>GO111MODULE=on</code> because I like my applications using Go modules and in some
older versions is not default.</li><li>Declare a <code>WORKDIR</code> so there&rsquo;s no question as to where the code should be
located at.</li><li>Install <code>git</code> and <code>ca-certificates</code>, because Go modules requires <code>git</code> in
order to clone dependencies and <code>ca-certificates</code> so it checks the SSL/TLS
certs in the connection are valid. I know I said <code>--no-cache</code> but I don&rsquo;t love
the extra empty directory being around my resulting images.</li><li>Copy <code>go.mod</code> and <code>go.sum</code> before the code, this way they can be cached
separately and only if there&rsquo;s a change in these files the next step will be
ran.</li><li><code>go mod download</code>, cached by the previous step.</li><li>Copy my source code and then build.</li></ul><p>As the name implies, a multi-stage Dockerfile has several stages, all of which
run in order during a <code>docker build -t foo .</code>. We ideally for a Go application
would like a builder and then the final result be copied into a lightweight
image. The base size for an image from <code>golang:alpine</code> is over 60 MB, if you&rsquo;re
using Go modules you&rsquo;ll need <code>git</code> for cloning during a <code>go mod download</code> and
<code>ca-certificates</code> if you want to validate the SSL certificates being used are
valid. That&rsquo;s already over 70MB and in most cases I end up with a binary around
8-17MB.</p><p>What if I could just copy the binary and run it? That&rsquo;s what the second part
does, so it just:</p><ul><li>Takes the <code>alpine</code> image as the start of it.</li><li>Installs <code>ca-certificates</code> so we can validate TLS certificates of external
services.</li><li>Copies the binary from the previous stage (note the use of <code>--from=builder</code>).</li><li>Declares a default <code>CMD</code> for <code>--help</code>.</li></ul><p>Why use <code>alpine</code> and not <code>scratch</code>? Basically because most of the apps I build
end up connecting to external services over TLS, and I really like to make sure
the certificates are valid. Otherwise, using <code>scratch</code> is enough and you can
decrease 5MB of the final size.</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/docker>docker</a></li><li><a href=/tags/go>go</a></li><li><a href=/tags/golang>golang</a></li><li><a href=/tags/deployment>deployment</a></li><li><a href=/tags/dockerfile>dockerfile</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/nrxr rel=me title=Github><i data-feather=github></i></a>
<a class=border></a></div><div class=footer-info>2023 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>